'use client';

import { BinanceExchangeInfo, BinanceSymbolInfo } from './types';

// Next.js API í”„ë¡ì‹œ ì‚¬ìš© (CORS ë¬¸ì œ í•´ê²°)
const BINANCE_EXCHANGE_API_PROXY = '/api/binance';

// ë°”ì´ë‚¸ìŠ¤ ì•ŒíŒŒì™€ ë¹—ì¸ì—ì„œ ê²¹ì¹˜ëŠ” ì½”ì¸ë“¤
export const BINANCE_ALPHA_COINS = new Set([
  'AERO', 'ATH', 'AVAIL', 'AVL', 'B3', 'BIGTIME', 'BLUE', 'BMT', 'C', 'CARV', 
  'COOKIE', 'DRIFT', 'EPT', 'ERA', 'F', 'FLOCK', 'G', 'GOAT', 'GRASS', 'H', 
  'HAEDAL', 'HOME', 'HUMA', 'HYPER', 'LA', 'LINEA', 'MERL', 'MEW', 'MLK', 
  'MOODENG', 'MORPHO', 'NEWT', 'NFT', 'NXPC', 'OBT', 'ONDO', 'OPEN', 'ORDER', 
  'PARTI', 'PEAQ', 'PLUME', 'POKT', 'PROMPT', 'PROVE', 'PUFFER', 'PUMP', 
  'PUMPBTC', 'RESOLV', 'SAFE', 'SAHARA', 'SD', 'SHELL', 'SIGN', 'SOON', 
  'SOPH', 'SPK', 'SUNDOG', 'SXT', 'SYRUP', 'TAIKO', 'TOWNS', 'TREE', 
  'VIRTUAL', 'XTER', 'ZETA', 'ZRC'
]);

/**
 * ì½”ì¸ì´ ë°”ì´ë‚¸ìŠ¤ ì•ŒíŒŒì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
 */
export function isBinanceAlphaCoin(symbol: string): boolean {
  return BINANCE_ALPHA_COINS.has(symbol);
}

// Next.js API í”„ë¡ì‹œ ì‚¬ìš© (CORS ë¬¸ì œ í•´ê²°)
const BINANCE_EXCHANGE_API_PROXY = '/api/binance';

/**
 * ë°”ì´ë‚¸ìŠ¤ Exchange Info API í˜¸ì¶œ (í”„ë¡ì‹œ ì‚¬ìš©)
 * ëª¨ë“  ê±°ë˜ ê°€ëŠ¥í•œ ì‹¬ë³¼ ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤
 */
export async function getBinanceExchangeInfo(): Promise<BinanceExchangeInfo> {
  try {
    console.log('Fetching Binance data via proxy...');
    const response = await fetch(BINANCE_EXCHANGE_API_PROXY, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log(`Received ${data.symbols?.length || 0} symbols from Binance`);
    return data;
  } catch (error) {
    console.error('Error fetching Binance exchange info:', error);
    throw error;
  }
}

/**
 * ê±°ë˜ ê°€ëŠ¥í•œ ë°”ì´ë‚¸ìŠ¤ ì‹¬ë³¼ë“¤ë§Œ í•„í„°ë§
 */
export async function getTradingBinanceSymbols(): Promise<BinanceSymbolInfo[]> {
  try {
    const exchangeInfo = await getBinanceExchangeInfo();
    
    return exchangeInfo.symbols.filter(symbol => 
      symbol.status === 'TRADING' && 
      symbol.isSpotTradingAllowed &&
      // USDT í˜ì–´ë§Œ í•„í„°ë§ (ë¹—ì¸ì´ KRW ê¸°ì¤€ì´ë¯€ë¡œ USDTë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë§¤í•‘)
      symbol.quoteAsset === 'USDT'
    );
  } catch (error) {
    console.error('Error filtering trading Binance symbols:', error);
    return [];
  }
}

/**
 * ë°”ì´ë‚¸ìŠ¤ ë² ì´ìŠ¤ ìì‚° ëª©ë¡ ì¶”ì¶œ
 * ì˜ˆ: BTCUSDT -> BTC
 */
export async function getBinanceBaseAssets(): Promise<Set<string>> {
  try {
    const tradingSymbols = await getTradingBinanceSymbols();
    const baseAssets = new Set<string>();
    
    tradingSymbols.forEach(symbol => {
      baseAssets.add(symbol.baseAsset);
    });
    
    return baseAssets;
  } catch (error) {
    console.error('Error getting Binance base assets:', error);
    return new Set();
  }
}

/**
 * ë¹—ì¸ ì‹¬ë³¼ì„ ë°”ì´ë‚¸ìŠ¤ ì‹¬ë³¼ë¡œ ë§¤í•‘
 * BTC_KRW -> BTCUSDT
 */
export function mapBithumbToBinanceSymbol(bithumbSymbol: string): string {
  const baseAsset = bithumbSymbol.replace('_KRW', '');
  return `${baseAsset}USDT`;
}

/**
 * ë°”ì´ë‚¸ìŠ¤ ì‹¬ë³¼ì„ ë¹—ì¸ ì‹¬ë³¼ë¡œ ë§¤í•‘
 * BTCUSDT -> BTC_KRW
 */
export function mapBinanceToBithumbSymbol(binanceSymbol: string): string {
  const baseAsset = binanceSymbol.replace('USDT', '');
  return `${baseAsset}_KRW`;
}

/**
 * ë¹—ì¸ê³¼ ë°”ì´ë‚¸ìŠ¤ì—ì„œ ê³µí†µìœ¼ë¡œ ê±°ë˜ë˜ëŠ” ì½”ì¸ë“¤ ì°¾ê¸°
 */
export async function findCommonCoins(bithumbSymbols: string[]): Promise<Map<string, string>> {
  try {
    console.log('Finding common coins...');
    console.log('Bithumb symbols to check:', bithumbSymbols.slice(0, 10), '...(total:', bithumbSymbols.length, ')');
    
    const binanceBaseAssets = await getBinanceBaseAssets();
    console.log('Binance base assets found:', binanceBaseAssets.size);
    console.log('Sample Binance assets:', Array.from(binanceBaseAssets).slice(0, 20));
    
    const commonCoins = new Map<string, string>(); // bithumb_symbol -> binance_symbol
    
    bithumbSymbols.forEach(bithumbSymbol => {
      const baseAsset = bithumbSymbol.replace('_KRW', '');
      
      if (binanceBaseAssets.has(baseAsset)) {
        const binanceSymbol = mapBithumbToBinanceSymbol(bithumbSymbol);
        commonCoins.set(bithumbSymbol, binanceSymbol);
        console.log(`âœ“ Common coin found: ${bithumbSymbol} â†’ ${binanceSymbol}`);
      } else {
        console.log(`âœ— Not on Binance: ${bithumbSymbol} (${baseAsset})`);
      }
    });
    
    console.log(`ğŸ¯ Final result: Found ${commonCoins.size} common coins between Bithumb and Binance`);
    console.log('Common coins map:', Array.from(commonCoins.entries()));
    return commonCoins;
  } catch (error) {
    console.error('âŒ Error finding common coins:', error);
    return new Map();
  }
}
